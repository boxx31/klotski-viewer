<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klotski Viewer</title>
    <link rel="icon" type="image/png" href="./favicon.png">
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; }
        body { background-color: #111; color: #fff; font-family: sans-serif; }
        canvas { display: block; }
        
        hr {
            border-color: #444;
            margin: 10px 0;
        }
        #highlight-ring {
            position: absolute;
            width: 20px;  
            height: 20px; 
            border: 2px solid magenta; 
            border-radius: 50%; 
            pointer-events: none; 
            display: none; 
            transform: translate(-50%, -50%); 
            z-index: 100;
        }

        #klotski-board-container {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 160px;
            height: 200px;
            background-color: #222;
            border: 2px solid #888;
            border-radius: 4px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(5, 1fr);
            z-index: 10;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            cursor: pointer; /* NEW: Indicate it's interactive */
        }
        .klotski-cell {
            width: 100%;
            height: 100%;
            border: 1px solid #444;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.6);
            user-select: none;
            transition: background-color 0.1s;
        }
        
        /* NEW: Style for the selected piece */
        .klotski-cell.selected {
            outline-offset: -2px;
            box-shadow: inset 0 0 10px rgba(255, 0, 255, 0.5);
        }

        #controls {
            position: absolute;
            top: 15px;
            right: 15px; 
            z-index: 10;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            min-width: 220px;
            font-size: 0.9em;
        }
        #controls label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        #controls input[type="file"] {
            margin-bottom: 10px;
            font-size: 0.8em;
        }
        #controls input[type="range"] {
            width: 110px;
            vertical-align: middle;
        }
        #controls span {
            vertical-align: middle;
            margin-left: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }

        #controls button {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 10px;
            margin: 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
            width: auto;
            box-sizing: border-box;
        }
        #controls button:hover {
            background-color: #555;
        }
        #controls button.active {
            background-color: #00aaff;
            border-color: #00aaff;
            font-weight: bold;
        }
        
        #instructions {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 10;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9em;
            line-height: 1.5;
            color: #eee;
        }
        #instructions code {
            background-color: #222;
            padding: 2px 5px;
            border-radius: 3px;
        }
        #node-info {
            position: absolute;
            bottom: 15px;  /* MODIFIED: Align with instructions */
            right: 15px;   /* MODIFIED: Move to right side */
            left: auto;    /* MODIFIED: Unset left position */
            z-index: 10;
            background-color: rgba(0,0,0,0.5);
            padding: 8px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 1.1em;
            color: #fff;
            display: none; /* Hide by default */
        }
    </style>
</head>
<body>
    <div id="highlight-ring"></div>
    <div id="klotski-board-container"></div>
    <div id="node-info"></div>
    
    <div id="instructions">
        <b>Controls (use PC):</b><br>
        1. <code>Click</code> screen to lock mouse. <code>Esc</code> to unlock.<br>
        2. Use <code>WASD</code> + <code>Mouse</code> to fly.<br>
        3. <code>Space</code> = Up, <code>Shift</code> = Down.<br>
        4. <code>Scroll</code> to change speed.<br>
        5. Drag and drop pieces on board to move.<br>
        6. <code>Ctrl+Click</code> a node to change board.
    </div>

    <div id="controls">

        <label for="fileInput">Choose a JSON file:</label>
        <input type="file" id="fileInput" accept=".json">
        <hr>
    
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <label for="speedSlider" style="margin-right: 10px; font-weight: bold;">Flight Speed:</label>
            <input type="range" id="speedSlider" min="50" max="5000" value="5000" step="50" style="width: 100px;">
            <span id="speedValue" style="width: 35px; text-align: right;">5000</span>
        </div>

        <div style="display: flex; align-items: center; margin-top: 5px;">
            <label for="speedSlider" style="margin-right: 10px; font-weight: bold; white-space: nowrap;">Node Color:</label>
            <div style="display: flex;">
                <button id="btnOff" class="active">None</button>
                <button id="btnDist">Start</button>
                <button id="btnSolutionDist">Solution</button>
            </div>
        </div>

        <hr>

        <strong>Position:</strong><br>
        <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 5px;">
            <input type="text" id="current-pos-input" readonly title="Current selected position" style="margin-top: 5px;">
            <button id="btnSetStartNode" style="white-space: nowrap; width: auto;" title="Recalculate all 'Start Distances' from the currently selected node">Set as Start</button>
        </div>
        
        <div style="display: flex; align-items: center; margin-top: 8px;">
            <input type="text" id="teleport-input" placeholder="Enter 20-char position..." title="Enter 20-char position and press Teleport" style="width: 100%; margin-right: 5px;">
            <button id="btnTeleport" title="Teleport to the specified position">Find</button>
            <button id="btnRandom" title="Teleport to a random node">Random</button>
        </div>

        <hr>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
            <strong>Highlighted Path:</strong>
            <div style="display: flex; align-items: center;">
                <input type="checkbox" id="traceToggle" checked style="margin-right: 8px;">
                <label for="traceToggle" style="user-select: none; cursor: pointer; white-space: nowrap;">Trace</label>
            </div>
        </div>

        <div id="path-info" title="Node-to-node path info" style="font-family: monospace; margin: 5px 0; min-height: 40px; background: #222; padding: 5px; border-radius: 4px;">
            Start: (None)<br>End: (None)
        </div>
        
        <div style="display: flex; justify-content: space-between; margin-top: 5px;">
            <button id="btnSetPathStart" title="Set highlighted node as path Start" style="white-space: nowrap;">Set Start</button>
            <button id="btnSetPathEnd" title="Set highlighted node as path End" style="white-space: nowrap;">Set End</button>
            <button id="btnCalcPath" title="Find shortest path between Start and End" style="white-space: nowrap;">Find Path</button>
            <button id="btnFindSolutionPath" title="Find shortest path from highlighted node to a solution" style="white-space: nowrap;">Solution Path</button>
        </div>
        
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Standard Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1.0, 25000);
        camera.up.set(0, 1, 0); 
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new PointerLockControls(camera, renderer.domElement);

        // --- Game Controls Setup ---
        const clock = new THREE.Clock();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let moveSpeed = 5000.0; 
        
        const onKeyDown = (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': moveUp = true; event.preventDefault(); break;
                case 'ShiftLeft': moveDown = true; break;
            }
        };
        const onKeyUp = (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'Space': moveUp = false; break;
                case 'ShiftLeft': moveDown = false; break;
            }
        };
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        renderer.domElement.addEventListener('click', (event) => {
            if (!event.ctrlKey) {
                controls.lock();
            }
        });
        renderer.domElement.addEventListener('wheel', onCanvasWheel, { passive: false });
        
        // --- Core Graph/Interaction Variables ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let nodesArray = []; 
        let nodes = null; 
        let nodeGeometry = null; 
        let highlightRingEl = null; 
        let highlightedPosition = null; 
        const tempVector = new THREE.Vector3(); 
        const colorAttributes = {}; 
        let activeColorAttributeName = 'default'; 
        let nodeInfoEl = null;

        // --- Position/Teleport State ---
        let currentPosEl = null;
        let teleportInputEl = null;

        // --- Path Tracing State ---
        let tracedPathNodeIds = [];
        let isPathTracerOn = true;

        // --- Shortest Path State ---
        let pathStartNode = null;
        let pathEndNode = null;
        let pathInfoEl = null;
        let pathHighlightMesh = null;

        // --- Klotski Game State ---
        let graphData = null; // Stores full loaded graph
        let currentBoard = []; // 20-char array of the current board state
        let highlightedNodeData = null; // The full data object for the selected node
        let dragStartCoords = { x: 0, y: 0 };
        let dragPieceChar = null;
        let dragMoveDetected = false; // To prevent multiple moves per drag
        const initialPosition = "abbcabbceddhefghi..j";
        const klotskiBoardEl = document.getElementById('klotski-board-container');
        const klotskiCells = [];
        const pieceColors = {
            '.': '#333', 'a': '#FF6347', 'b': '#4682B4', 'c': '#32CD32', 'd': '#FFD700',
            'e': '#6A5ACD', 'f': '#DAA520', 'g': '#20B2AA', 'h': '#FF69B4', 'i': '#8A2BE2', 'j': '#A52A2A'
        };

        // --- Color Scale Helper Function ---
        function mapValueToColor(value, min, max) {
            const color = new THREE.Color();
            if (min === max) { color.setHSL(0.66, 1.0, 0.5); return color; }
            const normalized = (value - min) / (max - min);
            const hue = 0.66 - (normalized * 0.66);
            color.setHSL(hue, 1.0, 0.5);
            return color;
        }

        // --- Klotski Board Setup ---
        for (let i = 0; i < 20; i++) {
            const cell = document.createElement('div');
            cell.classList.add('klotski-cell');
            klotskiBoardEl.appendChild(cell);
            klotskiCells.push(cell);
        }
        klotskiBoardEl.addEventListener('mousedown', onKlotskiMouseDown);
        
        /**
         * Updates the Klotski board display AND the internal game state.
         * @param {string} representation - The 20-character string.
         */
        function updateKlotskiBoard(representation) {
            if (!representation || representation.length !== 20) {
                representation = "...................."; // Default to empty
            }
            
            currentBoard = representation.split('');
            
            for (let i = 0; i < 20; i++) {
                const char = currentBoard[i];
                klotskiCells[i].style.backgroundColor = pieceColors[char] || '#CCC';
                klotskiCells[i].textContent = char === '.' ? '' : char;
                klotskiCells[i].classList.remove('selected'); // Clear all selections
            }
        }
        updateKlotskiBoard("...................."); // Initialize

        function updateNodeInfoLabel() {
            if (!nodeInfoEl) return; // Not loaded yet

            if (!highlightedNodeData) {
                nodeInfoEl.style.display = 'none'; // Hide if no node is selected
                return;
            }

            if (activeColorAttributeName === 'dist') {
                nodeInfoEl.style.display = 'block';
                nodeInfoEl.textContent = `Start Dist: ${highlightedNodeData.dist}`;
            } else if (activeColorAttributeName === 'solution') {
                nodeInfoEl.style.display = 'block';
                nodeInfoEl.textContent = `Solution Dist: ${highlightedNodeData.solution_dist}`;
            } else {
                nodeInfoEl.style.display = 'none'; 
            }
        }

        function selectNode(nodeData) {
            if (!nodeData) {
                // Clear selection
                highlightedNodeData = null;
                highlightedPosition = null;
                updateKlotskiBoard("....................");
                if (currentPosEl) currentPosEl.value = "....................";
            } else {
                highlightedNodeData = nodeData;
                highlightedPosition = new THREE.Vector3(nodeData.x, -nodeData.y, -nodeData.z);
                updateKlotskiBoard(nodeData.representation);
                if (currentPosEl) currentPosEl.value = nodeData.representation;
            }
            updateNodeInfoLabel();
        }

        function updatePathInfoLabel() {
            if (!pathInfoEl) return;
            const startText = pathStartNode ? pathStartNode.representation : "(None)";
            const endText = pathEndNode ? pathEndNode.representation : "(None)";
            pathInfoEl.innerHTML = `Start: ${startText}<br>End: ${endText}`;
        }

        function onMouseDown(event) {
            if (controls.isLocked || !event.ctrlKey) {
                return;
            }
            if (!nodes || nodesArray.length === 0) {
                return;
            }
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            raycaster.params.Points.threshold = 100.0; 
            
            const intersects = raycaster.intersectObject(nodes);

            if (intersects.length > 0) {
                intersects.sort((a, b) => a.distanceToRay - b.distanceToRay);
                const index = intersects[0].index;
                const nodeData = nodesArray[index];
                
                if (nodeData) {
                    selectNode(nodeData);
                }
            } else {
                selectNode(null); 
            }
        }
        window.addEventListener('mousedown', onMouseDown, false);
        
        
        const PIECE_TYPE_1x1 = new Set(['f', 'g', 'i', 'j']);
        const PIECE_TYPE_1x2 = new Set(['a', 'c', 'e', 'h']);
        const PIECE_TYPE_2x1 = new Set(['d']);
        // 'b' (2x2) is its own unique type.

        /**
         * Helper function for the canonicalizer.
         * Modifies the array in-place, replacing all pieces of a given type
         * with a sorted list of those same pieces.
         * @param {string[]} repArray - The board array (being modified).
         * @param {Set<string>} pieceTypeSet - The set of pieces to canonicalize (e.g., PIECE_TYPE_1x1).
         */
        function sortPiecesInArray(repArray, pieceTypeSet) {
            // Find and sort all pieces of this type
            const pieces = repArray
                .filter(char => pieceTypeSet.has(char))
                .sort();
                
            if (pieces.length === 0) {
                return; // No pieces of this type, do nothing
            }

            // Re-iterate over the array, replacing pieces in sorted order
            let pieceIndex = 0;
            for (let i = 0; i < repArray.length; i++) {
                if (pieceTypeSet.has(repArray[i])) {
                    repArray[i] = pieces[pieceIndex++];
                }
            }
        }

        /**
         * Canonicalizes a representation string by sorting all permutable pieces
         * (1x1, 1x2, 2x1) among themselves.
         * @param {string} repString - The 20-char representation string.
         * @returns {string} The canonical representation.
         */
        function canonicalize(repString) {
            const repArray = repString.split('');
            
            // Canonicalize each permutable piece type independently
            sortPiecesInArray(repArray, PIECE_TYPE_1x1);
            sortPiecesInArray(repArray, PIECE_TYPE_1x2);
            sortPiecesInArray(repArray, PIECE_TYPE_2x1);
            
            return repArray.join('');
        }
        
        function onCanvasWheel(event) {
            // Only change speed when in fly mode
            if (controls.isLocked === true) {
                event.preventDefault(); // Stop page from scrolling

                const speedSlider = document.getElementById('speedSlider');
                const speedValueEl = document.getElementById('speedValue');
                if (!speedSlider || !speedValueEl) return;

                const direction = Math.sign(event.deltaY); // -1 for up, +1 for down
                const currentVal = parseFloat(speedSlider.value);
                const step = parseFloat(speedSlider.step);
                const min = parseFloat(speedSlider.min);
                const max = parseFloat(speedSlider.max);

                // We subtract: scroll up (negative delta) should increase speed
                let newVal = currentVal - (direction * step * 5); // Multiply by 5 for sensitivity
                newVal = Math.max(min, Math.min(max, newVal));

                if (newVal !== currentVal) {
                    speedSlider.value = newVal;
                    moveSpeed = newVal;
                    speedValueEl.textContent = newVal;
                }
            }
        }

        function onKlotskiMouseDown(event) {
            if (!highlightedNodeData) return; // Can't play
            event.preventDefault();

            // Get index from the clicked cell
            const clickedIndex = klotskiCells.indexOf(event.target);
            if (clickedIndex === -1) return; // Clicked grid gap
            
            const pieceChar = currentBoard[clickedIndex];
            if (pieceChar === '.') return; // Clicked empty space

            // Highlight all cells of this piece
            for(let i = 0; i < 20; i++) {
                if (currentBoard[i] === pieceChar) {
                    klotskiCells[i].classList.add('selected');
                }
            }

            dragPieceChar = pieceChar;
            dragStartCoords = { x: event.clientX, y: event.clientY };
            dragMoveDetected = false;

            // Add move/up listeners to the *window* to capture drag
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('mouseup', onWindowMouseUp);
        }

        function onWindowMouseMove(event) {
            if (!dragPieceChar || dragMoveDetected) return;
            event.preventDefault();

            const dx = event.clientX - dragStartCoords.x;
            const dy = event.clientY - dragStartCoords.y;
            
            const threshold = 30; // Min pixels to move to trigger
            let moveDirection = null; // [dx, dy] for attemptMove

            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
                // Horizontal move
                moveDirection = [Math.sign(dx), 0]; // [1, 0] or [-1, 0]
                dragMoveDetected = true;
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > threshold) {
                // Vertical move
                moveDirection = [0, Math.sign(dy)]; // [0, 1] or [0, -1]
                dragMoveDetected = true;
            }

            if (moveDirection) {
                // Try to perform the move
                const [moveSuccess, newBoard] = attemptMove(dragPieceChar, moveDirection[0], moveDirection[1]);

                if (moveSuccess) {
                    const newRep = newBoard.join('');
                    const neighborNode = findNeighborByRep(newRep);
                    
                    if (neighborNode) {
                        if (isPathTracerOn) { 
                            const currentPath = tracedPathNodeIds;
                            const currentNodeId = highlightedNodeData.id;
                            const nextNodeId = neighborNode.id;
                            if (currentPath.length === 0) {
                                tracedPathNodeIds = [currentNodeId, nextNodeId];
                            } else if (currentPath[currentPath.length - 1] === currentNodeId) {
                                tracedPathNodeIds.push(nextNodeId);
                            } else {
                                tracedPathNodeIds = [currentNodeId, nextNodeId];
                            }
                            highlightPath(tracedPathNodeIds);
                        }
                        
                        selectNode(neighborNode); // Move to the new node
                    } else {
                        console.warn("Valid drag move, but no neighbor found for rep:", newRep);
                    }
                }
                
                // Stop the drag immediately after one move is detected (success or fail)
                onWindowMouseUp(); 
            }
        }

        function onWindowMouseUp() {
            // The move is over, successful or not. Clean up highlights.
            if (dragPieceChar) {
                for(let i = 0; i < 20; i++) {
                    klotskiCells[i].classList.remove('selected');
                }
            }
            dragPieceChar = null;
            window.removeEventListener('mousemove', onWindowMouseMove);
            window.removeEventListener('mouseup', onWindowMouseUp);
        }

        /**
         * Tries to move a piece, returns new board state if successful.
         */
        function attemptMove(pieceChar, dx, dy) {
            const board = [...currentBoard]; // Create a copy
            const pieceIndices = [];
            for (let i = 0; i < 20; i++) {
                if (board[i] === pieceChar) {
                    pieceIndices.push(i);
                }
            }
            
            const newPieceIndices = [];
            
            for (const index of pieceIndices) {
                const x = index % 4;
                const y = Math.floor(index / 4);
                
                const newX = x + dx;
                const newY = y + dy;
                
                if (newX < 0 || newX > 3 || newY < 0 || newY > 4) {
                    return [false, null];
                }
                
                const newIndex = newY * 4 + newX;
                
                if (board[newIndex] !== '.' && board[newIndex] !== pieceChar) {
                    return [false, null];
                }
                
                newPieceIndices.push(newIndex);
            }
            
            const newBoard = [...board]; // Create a new copy to modify
            for (const index of pieceIndices) {
                newBoard[index] = '.';
            }
            for (const index of newPieceIndices) {
                newBoard[index] = pieceChar;
            }
            
            return [true, newBoard];
        }

        /**
         * Finds a neighbor by its *canonical* representation.
         */
        function findNeighborByRep(representation) {
            if (!highlightedNodeData || !graphData) return null;
            
            const targetCanonicalRep = canonicalize(representation);
            const neighborIds = new Set(highlightedNodeData.neighbors);
            
            for (const neighborId of neighborIds) {
                const neighborNode = graphData[neighborId];
                if (neighborNode) {
                    const neighborCanonicalRep = canonicalize(neighborNode.representation);
                    if (neighborCanonicalRep === targetCanonicalRep) {
                        return neighborNode;
                    }
                }
            }
            return null;
        }

        /**
         * Runs a Breadth-First Search (BFS) to find the shortest path.
         * @param {string} startNodeId - The ID of the starting node.
         * @param {string} endNodeId - The ID of the target node.
         * @returns {number} The shortest distance, or -1 if no path is found.
         */
        function runBFS(startNodeId, endNodeId) {
            if (!graphData) return null;
            
            const queue = []; // Use array as a queue: [nodeId]
            const predecessors = new Map(); // Map to store predecessors (to rebuild the path)

            queue.push(startNodeId);
            predecessors.set(startNodeId, null); // Mark start node
            
            let head = 0; 
            
            while (head < queue.length) {
                const currentId = queue[head++];
                
                // Check if we found the target
                if (currentId === endNodeId) {
                    // Reconstruct path
                    const path = [];
                    let step = endNodeId;
                    while (step !== null) { // Backtrack from end to start
                        path.push(step);
                        step = predecessors.get(step);
                    }
                    return path.reverse(); // Return [start, ..., end]
                }
                
                const currentNode = graphData[currentId];
                if (!currentNode) continue; 

                // Add all unvisited neighbors to the queue
                for (const neighborId of new Set(currentNode.neighbors)) {
                    if (!predecessors.has(neighborId)) { // If not visited
                        predecessors.set(neighborId, currentId);
                        queue.push(neighborId);
                    }
                }
            }
            
            return null;
        }

        /**
         * Runs a BFS from a single node to all other reachable nodes.
         * @param {string} startNodeId - The ID of the node to start from.
         * @returns {Map<string, number>} A Map where keys are node IDs and values are the distance.
         */
        function runBFS_OneToAll(startNodeId) {
            if (!graphData) return new Map();
            
            const distances = new Map(); // [nodeId, distance]
            const queue = []; // [nodeId, distance]
            
            // Add the start node to the queue
            queue.push([startNodeId, 0]);
            distances.set(startNodeId, 0);
            
            let head = 0; 
            
            while (head < queue.length) {
                const [currentId, distance] = queue[head++];
                const currentNode = graphData[currentId];
                if (!currentNode) continue; 

                // Add all unvisited neighbors to the queue
                for (const neighborId of new Set(currentNode.neighbors)) {
                    if (!distances.has(neighborId)) { // If not visited
                        distances.set(neighborId, distance + 1);
                        queue.push([neighborId, distance + 1]);
                    }
                }
            }
            
            return distances; // Map of all reachable node distances
        }

        /**
         * Applies a new set of distances to all nodes and rebuilds the color buffer.
         * @param {Map<string, number>} distances - The map from runBFS_OneToAll.
         */
        function applyNewDistances(distances) {
            if (!nodesArray || !colorAttributes.dist) return;

            console.time("Applying new distances");
            let newMaxDist = 0;
            const newNodeColorsByDist = [];

            // Pass 1: Update .dist property on all nodes and find new max distance
            for (const node of nodesArray) {
                // Get new distance, default to Infinity if unreachable
                const newDist = distances.get(node.id) ?? Infinity;
                node.dist = newDist;
                
                if (newDist !== Infinity && newDist > newMaxDist) {
                    newMaxDist = newDist;
                }
            }

            console.log("New Max 'Start Distance':", newMaxDist);

            // Pass 2: Rebuild the color array using the new distances
            for (const node of nodesArray) {
                const distColor = mapValueToColor(node.dist, 0, newMaxDist);
                newNodeColorsByDist.push(distColor.r, distColor.g, distColor.b);
            }

            // Pass 3: Update the Three.js geometry
            colorAttributes.dist = new THREE.Float32BufferAttribute(newNodeColorsByDist, 3);
            
            // If we are currently in "Start Distance" mode, apply the new colors
            if (activeColorAttributeName === 'dist') {
                nodeGeometry.setAttribute('color', colorAttributes.dist);
                nodeGeometry.attributes.color.needsUpdate = true;
            }

            // Refresh the info label if a node is selected
            updateNodeInfoLabel();
            
            console.timeEnd("Applying new distances");
        }

        /**
         * Reconstructs the shortest path to a solution node using pre-calculated 'solution_dist'.
         * @param {object} startNode - The node object to start from.
         * @returns {string[]|null} The path as an array of node IDs, or null.
         */
        function findSolutionPath(startNode) {
            if (!graphData) return null;
            
            const path = [startNode.id];
            let currentNode = startNode;
            let currentDist = startNode.solution_dist;
            
            // Walk "downhill" from the start node's distance to 0
            while (currentDist > 0) {
                const targetDist = currentDist - 1;
                let foundNextStep = false;
                
                // Check all unique neighbors
                for (const neighborId of new Set(currentNode.neighbors)) {
                    const neighborNode = graphData[neighborId];
                    
                    // If this neighbor is one step closer to the solution, take it
                    if (neighborNode && neighborNode.solution_dist === targetDist) {
                        path.push(neighborId);
                        currentNode = neighborNode;
                        currentDist = neighborNode.solution_dist;
                        foundNextStep = true;
                        break;
                    }
                }
                
                if (!foundNextStep) {
                    console.error("Could not find next step in solution path. Graph inconsistent.");
                    return null;
                }
            }
            
            return path; // Path successfully found
        }

        /**
         * Highlights a path on the graph by updating the pathHighlightMesh.
         * @param {string[]|null} path - An array of node IDs, or null to clear.
         */
        function highlightPath(path) {
            if (!pathHighlightMesh || !graphData) return;

            // If path is null or too short, clear the geometry
            if (path === null || path.length < 2) {
                pathHighlightMesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
                return;
            }
            
            const positions = [];
            for (let i = 0; i < path.length - 1; i++) {
                const nodeA = graphData[path[i]];
                const nodeB = graphData[path[i+1]];
                
                if (nodeA && nodeB) {
                    // Add line segment (A -> B), using the inverted coordinates
                    positions.push(nodeA.x, -nodeA.y, -nodeA.z);
                    positions.push(nodeB.x, -nodeB.y, -nodeB.z);
                }
            }
            
            // Update the geometry
            pathHighlightMesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            pathHighlightMesh.geometry.computeBoundingSphere();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const jsonString = e.target.result;
                        const data = JSON.parse(jsonString);
                
                        graphData = data;
                        
                        // Run all setup code that depends on the data
                        console.time('Graph Processing');
                        const nodePositions = [];
                        const edgePositions = [];
                        const nodeColorsDefault = [];
                        const nodeColorsByDist = [];
                        const nodeColorsBySolutionDist = [];
                        const nodeMap = new Map();
                        nodesArray = []; 
                        let minDist = Infinity, maxDist = -Infinity, minSolDist = Infinity, maxSolDist = -Infinity;

                        // First pass (rotate graph, find min/max)
                        for (const nodeId in data) {
                            const node = data[nodeId];
                            node.id = nodeId; 
                            nodeMap.set(nodeId, new THREE.Vector3(node.x, -node.y, -node.z));
                            nodesArray.push(node); 
                            if (node.dist < minDist) minDist = node.dist;
                            if (node.dist > maxDist) maxDist = node.dist;
                            if (node.solution_dist < minSolDist) minSolDist = node.solution_dist;
                            if (node.solution_dist > maxSolDist) maxSolDist = node.solution_dist;
                        }

                        // Second pass (build color/position arrays)
                        const defaultColor = new THREE.Color(0x00aaff);
                        for (const node of nodesArray) {
                            nodePositions.push(node.x, -node.y, -node.z);
                            nodeColorsDefault.push(defaultColor.r, defaultColor.g, defaultColor.b);
                            const distColor = mapValueToColor(node.dist, minDist, maxDist);
                            nodeColorsByDist.push(distColor.r, distColor.g, distColor.b);
                            const solDistColor = mapValueToColor(node.solution_dist, minSolDist, maxSolDist);
                            nodeColorsBySolutionDist.push(solDistColor.r, solDistColor.g, solDistColor.b);
                        }

                        // Third pass (build edge array)
                        for (const nodeId in data) {
                            const sourcePos = nodeMap.get(nodeId); 
                            for (const neighborId of data[nodeId].neighbors) {
                                const targetPos = nodeMap.get(neighborId);
                                if (sourcePos && targetPos) {
                                    edgePositions.push(sourcePos.x, sourcePos.y, sourcePos.z);
                                    edgePositions.push(targetPos.x, targetPos.y, targetPos.z);
                                }
                            }
                        }
                        console.timeEnd('Graph Processing');
                        
                        // Create Geometry
                        console.time('Geometry Creation');
                        nodeGeometry = new THREE.BufferGeometry(); 
                        nodeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nodePositions, 3));
                        colorAttributes.default = new THREE.Float32BufferAttribute(nodeColorsDefault, 3);
                        colorAttributes.dist = new THREE.Float32BufferAttribute(nodeColorsByDist, 3);
                        colorAttributes.solution = new THREE.Float32BufferAttribute(nodeColorsBySolutionDist, 3);
                        nodeGeometry.setAttribute('color', colorAttributes.default);
                        const nodeMaterial = new THREE.PointsMaterial({ vertexColors: true, size: 4, sizeAttenuation: true });
                        nodes = new THREE.Points(nodeGeometry, nodeMaterial); 
                        scene.add(nodes);

                        const edgeGeometry = new THREE.BufferGeometry();
                        edgeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(edgePositions, 3));
                        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.25 });
                        const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                        scene.add(edges);
                        
                        const pathGeo = new THREE.BufferGeometry();
                        const pathMat = new THREE.LineBasicMaterial({ color: 0xFF00FF, transparent: true, opacity: 0.8, depthTest: false });
                        pathHighlightMesh = new THREE.LineSegments(pathGeo, pathMat);
                        pathHighlightMesh.renderOrder = 998;
                        scene.add(pathHighlightMesh);
                        console.timeEnd('Geometry Creation');

                        // Get all UI elements
                        highlightRingEl = document.getElementById('highlight-ring');
                        nodeInfoEl = document.getElementById('node-info');
                        pathInfoEl = document.getElementById('path-info');
                        currentPosEl = document.getElementById('current-pos-input');
                        teleportInputEl = document.getElementById('teleport-input');
                        
                        // Position Camera
                        const firstNode = data[Object.keys(data)[0]];
                        if (firstNode) {
                            camera.position.set(firstNode.x, -firstNode.y, -firstNode.z + 5000); 
                        } else {
                            camera.position.z = 5;
                        }

                        // Select initial node
                        const canonicalStartRep = canonicalize(initialPosition);
                        const initialStartNode = nodesArray.find(n => 
                            canonicalize(n.representation) === canonicalStartRep
                        );

                        if (initialStartNode) {
                            const distances = runBFS_OneToAll(initialStartNode.id);
                            applyNewDistances(distances);
                            selectNode(initialStartNode);
                        } else {
                            console.warn("Could not find the specified initial start node!");
                            alert("Warning: Could not find the default start node 'abbcabbceddhefghi..j'. The original 'dist' values from the JSON will be used.");
                        }
                        
                        // Attach all button listeners
                        const btnOff = document.getElementById('btnOff');
                        const btnDist = document.getElementById('btnDist');
                        const btnSolutionDist = document.getElementById('btnSolutionDist');
                        const buttons = [btnOff, btnDist, btnSolutionDist];
                        function setActiveButton(activeBtn) {
                            buttons.forEach(btn => btn.classList.remove('active'));
                            activeBtn.classList.add('active');
                        }
                        btnOff.addEventListener('click', () => { 
                            nodeGeometry.setAttribute('color', colorAttributes.default);
                            nodeGeometry.attributes.color.needsUpdate = true; 
                            activeColorAttributeName = 'default'; 
                            setActiveButton(btnOff);
                            updateNodeInfoLabel();
                        });
                        btnDist.addEventListener('click', () => {
                            nodeGeometry.setAttribute('color', colorAttributes.dist);
                            nodeGeometry.attributes.color.needsUpdate = true;
                            activeColorAttributeName = 'dist'; 
                            setActiveButton(btnDist);
                            updateNodeInfoLabel();
                        });
                        btnSolutionDist.addEventListener('click', () => {
                            nodeGeometry.setAttribute('color', colorAttributes.solution);
                            nodeGeometry.attributes.color.needsUpdate = true;
                            activeColorAttributeName = 'solution'; 
                            setActiveButton(btnSolutionDist);
                            updateNodeInfoLabel();
                        });
                        
                        const speedSlider = document.getElementById('speedSlider');
                        const speedValueEl = document.getElementById('speedValue');
                        moveSpeed = parseFloat(speedSlider.value);
                        speedValueEl.textContent = moveSpeed;
                        speedSlider.addEventListener('input', () => {
                            moveSpeed = parseFloat(speedSlider.value);
                            speedValueEl.textContent = moveSpeed;
                        });
                        
                        document.getElementById('btnTeleport').addEventListener('click', () => {
                            const targetRep = teleportInputEl.value;
                            if (targetRep.length !== 20) {
                                alert("Invalid position string. Must be 20 characters long."); return;
                            }
                            const canonicalTarget = canonicalize(targetRep);
                            const foundNode = nodesArray.find(node => canonicalize(node.representation) === canonicalTarget);
                            if (foundNode) {
                                selectNode(foundNode);
                            } else {
                                alert("A node with that position was not found in the graph.");
                            }
                        });
                        document.getElementById('btnRandom').addEventListener('click', () => {
                            if (!nodesArray || nodesArray.length === 0) return;

                            const randomIndex = Math.floor(Math.random() * nodesArray.length);
                            const randomNode = nodesArray[randomIndex];

                            if (randomNode) {
                                selectNode(randomNode);
                            }
                        });

                        document.getElementById('btnSetStartNode').addEventListener('click', () => {
                            if (!highlightedNodeData) {
                                alert("Please select a node first by Ctrl+Clicking it.");
                                return;
                            }

                            const startNodeId = highlightedNodeData.id;

                            setTimeout(() => {
                                console.time("One-to-All BFS");
                                const distances = runBFS_OneToAll(startNodeId);
                                console.timeEnd("One-to-All BFS");
                                
                                applyNewDistances(distances);
                            }, 10);
                        });
                        
                        document.getElementById('btnSetPathStart').addEventListener('click', () => {
                            if (highlightedNodeData) {
                                pathStartNode = highlightedNodeData;
                                updatePathInfoLabel();
                            } else {
                                alert("Please select a node first by Ctrl+Clicking it.");
                            }
                        });

                document.getElementById('btnSetPathEnd').addEventListener('click', () => {
                    if (highlightedNodeData) {
                        pathEndNode = highlightedNodeData;
                        updatePathInfoLabel();
                    } else {
                        alert("Please select a node first by Ctrl+Clicking it.");
                    }
                });
                
                document.getElementById('btnCalcPath').addEventListener('click', () => {
                    if (!pathStartNode || !pathEndNode) {
                        alert("Please set both a Start and an End node first."); return;
                    }
                    highlightPath(null);
                    if (pathStartNode.id === pathEndNode.id) {
                        alert("Start and End nodes are the same. Distance is 0.");
                        pathInfoEl.innerHTML = `Start: ${pathStartNode.representation}<br>End: ${pathEndNode.representation}<br>Distance: 0`;
                        return;
                    }
                    pathInfoEl.innerHTML = `Start: ${pathStartNode.representation}<br>End: ${pathEndNode.representation}<br>Calculating...`;
                    setTimeout(() => {
                        console.time("BFS Pathfind");
                        const path = runBFS(pathStartNode.id, pathEndNode.id);
                        console.timeEnd("BFS Pathfind");
                        if (path === null) {
                            pathInfoEl.innerHTML = `Start: ${pathStartNode.representation}<br>End: ${pathEndNode.representation}<br>No Path Found`;
                        } else {
                            const distance = path.length - 1;
                            pathInfoEl.innerHTML = `Start: ${pathStartNode.representation}<br>End: ${pathEndNode.representation}<br>Distance: ${distance}`;
                            highlightPath(path);
                        }
                    }, 10);
                });
                
                document.getElementById('btnFindSolutionPath').addEventListener('click', () => {
                    if (!highlightedNodeData) {
                        alert("Please select a node first by Ctrl+Clicking it."); return;
                    }
                    if (highlightedNodeData.solution_dist === 0) {
                        alert("This is already a solution node.");
                        highlightPath(null);
                        return;
                    }
                    highlightPath(null);
                    console.time("Solution Pathfind");
                    const path = findSolutionPath(highlightedNodeData);
                    console.timeEnd("Solution Pathfind");
                    if (path) {
                        highlightPath(path);
                    } else {
                        alert("Could not reconstruct path to solution.");
                    }
                });

                        document.getElementById('traceToggle').addEventListener('change', (event) => {
                            isPathTracerOn = event.target.checked;
                        });

                    } catch (parseErr) { console.error('Error parsing JSON:', parseErr); }
                };
                reader.onerror = (err) => { console.error('Error reading file:', err); };
                reader.readAsText(file);
            }
        });
        
        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (controls.isLocked === true) {
                const moveAmount = moveSpeed * delta;
                if (moveForward) controls.moveForward(moveAmount);
                if (moveBackward) controls.moveForward(-moveAmount);
                if (moveLeft) controls.moveRight(-moveAmount);
                if (moveRight) controls.moveRight(moveAmount);
                if (moveUp) camera.position.y += moveAmount; 
                if (moveDown) camera.position.y -= moveAmount;
            }

            if (highlightRingEl) {
                if (highlightedPosition) {
                    tempVector.copy(highlightedPosition);
                    tempVector.project(camera);
                    if (tempVector.z > 1) {
                        highlightRingEl.style.display = 'none';
                    } else {
                        const x = (tempVector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (tempVector.y * -0.5 + 0.5) * window.innerHeight;
                        highlightRingEl.style.display = 'block';
                        highlightRingEl.style.left = `${x}px`;
                        highlightRingEl.style.top = `${y}px`;
                    }
                } else {
                    highlightRingEl.style.display = 'none';
                }
            }
            
            renderer.render(scene, camera);
        }

        // --- Start Everything ---
        animate();

    </script>
</body>
</html>
